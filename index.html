<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>POCv3</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --w: 320px;
      --h: 14px;
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      padding: 20px;
    }

    .row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .stack {
      display: grid;
      gap: 6px;
      margin-bottom: 20px;
    }

    .bar-container {
      width: var(--w);
      height: var(--h);
      border: 1px solid #000;
      position: relative;
      background: #eee;
    }

    .bar {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 100%;
      background: linear-gradient(90deg, #2ecc71, #27ae60);
    }

    .npc {
      margin-top: 10px;
    }

    .tag {
      font-size: 12px;
      opacity: 0.7;
    }

    button {
      padding: 6px 10px;
      cursor: pointer;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .right-buttons {
      display: inline-flex;
      gap: 8px;
      margin-left: 10px;
      flex-wrap: wrap;
    }

    .muted {
      color: #b00;
      font-weight: 600;
    }

    .panel {
      padding: 8px 10px;
      border: 1px dashed #aaa;
      background: #fafafa;
      margin-top: 12px;
    }

    .small {
      font-size: 12px;
    }

    .section-header {
      display: flex;
      gap: 12px;
      align-items: baseline;
    }
  </style>

  <script>
    /* ============================================================
       CONFIG — All user-editable parameters live here
       ============================================================ */
    const CONFIG = {
      STATE: {
        START: 'menu'
      },

      USER: {
        MAX_STAMINA: 100,           // starting & cap for user stamina
        BASE_TICK_SPEED: 3,         // default stamina drain speed [units per second]
        DISPLAY_DECIMALS: 0
      },

      NPC: {
        COUNT: 5,                   // how many NPCs to spawn
        STAMINA_STEPS: [50, 100, 150], // NPC max stamina chosen from these
        BASE_TICK_SPEED: 3,         // NPC drain speed [units per second]
        DISPLAY_DECIMALS: 0
      },

      CLICK: {
        // Ranges for click effects (inclusive bounds)
        USER_REDUCTION_RANGE: [25, 50], // Water — user damage
        NPC_REDUCTION_RANGE: [25, 50],  // Water — per NPC damage
        BIRCH_REDUCTION_RANGE: [9, 18], // Birch — affects targeted NPC only
        BIRCH_AFFECTED_BY_HAT: false    // whether Hat also scales Birch clicks
      },

      SEEDS: {
        USER_CLICK: 12345, // seed for user click randomness (Water)
        NPC_CLICK: 67890,  // seed for NPC click randomness (Water)
        NPC_INIT: 13579,   // seed for picking NPC initial stamina steps
        BIRCH: 24680       // seed for Birch per-NPC (each NPC gets a derived stream)
      },

      EFFECTS: {
        BEER: {
          SPEED_DELTA: -1, // additive change to user tick speed (e.g., -1 => 3/s -> 2/s)
          DURATION_S: 10
        },

        ICE_CREAM: {
          AMOUNT: 80        // "Ice Cream" button amount
        },

        HAT: {
          REDUCTION_FACTOR: 0.20, // Water damage multiplier while Hat is active
          DURATION_S: 15,
          AFFECTS_USER_ONLY: true
        }
      },

      ECONOMY: {
        STARTING_COINS: 0,
        PERSIST_COINS: false, // if true, store coins in localStorage across reloads
        STORAGE_KEY: 'coins_total'
      },

      ITEMS: {
        WATER: { price: 1 },
        BEER: { price: 1 },
        ICE_CREAM: { price: 1 },
        HAT: { price: 1 }
      },

      DELAYS: {
        // "Delay" modifier: disable button after pressing for this many seconds
        WATER: 1,
        BEER: 1,
        ICE_CREAM: 1,
        HAT: 1,
        BIRCH: 1,
        RESET: 0
      },

      UI: {
        DISABLE_BUTTONS_AT_ZERO: true
      }
    };
    /* ===================== end CONFIG ===================== */

    /* ------------------------------------------------------------
       Game State (modular, extensible)
       ------------------------------------------------------------ */
    const GameState = {
      current: CONFIG.STATE.START,
      set(state) {
        this.current = state;
        syncUIState();
      },
      is(state) {
        return this.current === state;
      }
    };

    /* ------------------------------------------------------------
       Economy & Inventory
       - Purchases only allowed in menu state.
       - Action buttons consume inventory while playing.
       ------------------------------------------------------------ */
    let coins = CONFIG.ECONOMY.STARTING_COINS;

    const inventory = {
      WATER: 0,
      BEER: 0,
      ICE_CREAM: 0,
      HAT: 0
    };

    function loadCoins() {
      if (!CONFIG.ECONOMY.PERSIST_COINS) return;
      const raw = localStorage.getItem(CONFIG.ECONOMY.STORAGE_KEY);
      const val = raw ? Number(raw) : NaN;
      coins = Number.isFinite(val) ? val : CONFIG.ECONOMY.STARTING_COINS;
    }

    function saveCoins() {
      if (!CONFIG.ECONOMY.PERSIST_COINS) return;
      localStorage.setItem(CONFIG.ECONOMY.STORAGE_KEY, String(coins));
    }

    function canAfford(itemKey) {
      return coins >= CONFIG.ITEMS[itemKey].price;
    }

    function buyItem(itemKey) {
      // Only allow buying items in menu state
      if (!GameState.is('menu')) return;
      if (!canAfford(itemKey)) return;
      coins -= CONFIG.ITEMS[itemKey].price;
      inventory[itemKey] += 1;
      saveCoins();
      updateEconomyUI();
    }

    function consumeItem(itemKey) {
      if (inventory[itemKey] <= 0) return false;
      inventory[itemKey] -= 1;
      updateEconomyUI();
      return true;
    }

    function updateEconomyUI() {
      document.getElementById('coins').textContent = String(coins);
      for (const k of Object.keys(inventory)) {
        const el = document.getElementById(`inv-${k}`);
        if (el) el.textContent = String(inventory[k]);
      }
    }

    /* ------------------------------------------------------------
       Seedable PRNG utilities (deterministic randoms per feature)
       ------------------------------------------------------------ */
    function mulberry32(seed) {
      let t = seed >>> 0;
      return function () {
        t += 0x6D2B79F5;
        let r = Math.imul(t ^ (t >>> 15), 1 | t);
        r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
        return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
      };
    }

    function randIntRange(rng, min, max) {
      // inclusive integer range using provided rng()
      const x = rng();
      return Math.floor(x * (max - min + 1)) + min;
    }

    /* ------------------------------------------------------------
       TimedEffects: time-bound modifiers (Beer / Hat / etc.)
       ------------------------------------------------------------ */
    class TimedEffects {
      constructor() {
        this.effects = [];
      }

      now() {
        return performance.now() / 1000; // seconds
      }

      add({ key, durationS, data = {}, onApply = null, onExpire = null }) {
        const t = this.now();
        const eff = { key, until: t + durationS, onExpire, data };
        if (onApply) onApply(eff);
        this.effects.push(eff);
      }

      isActive(key) {
        const t = this.now();
        return this.effects.some(e => e.key === key && e.until > t);
      }

      getRemainingMax(key) {
        const t = this.now();
        let maxLeft = 0;
        this.effects.forEach(e => {
          if (e.key === key && e.until > t) {
            maxLeft = Math.max(maxLeft, e.until - t);
          }
        });
        return maxLeft;
      }

      purgeExpired() {
        const t = this.now();
        this.effects = this.effects.filter(e => {
          if (e.until <= t) {
            if (e.onExpire) e.onExpire(e);
            return false;
          }
          return true;
        });
      }

      // Utility: sum remaining time for effects whose key starts with a prefix
      sumRemainingByPrefix(prefix) {
        const t = this.now();
        return this.effects
          .filter(e => String(e.key).startsWith(prefix) && e.until > t)
          .reduce((acc, e) => acc + (e.until - t), 0);
      }
    }

    /* ------------------------------------------------------------
       Core game actors
       ------------------------------------------------------------ */
    class Actor {
      constructor(max, baseTickSpeed, displayDecimals = 0) {
        this.max = max;
        this.value = max;
        this.baseTickSpeed = baseTickSpeed;
        this.displayDecimals = displayDecimals;
        this.speedAdditions = 0;
        // meta flags for reward logic
        this._wasZero = false;
        this.finishedBeforeUser = false;
      }

      get tickSpeed() {
        return Math.max(0, this.baseTickSpeed + this.speedAdditions);
      }

      tick(dt) {
        this.value = Math.max(0, this.value - this.tickSpeed * dt);
      }

      addSpeed(delta) {
        this.speedAdditions += delta;
      }

      cap() {
        this.value = Math.min(this.max, this.value);
      }

      add(amount) {
        this.value = Math.min(this.max, this.value + amount);
      }

      asText() {
        return this.value.toFixed(this.displayDecimals);
      }

      percent() {
        return (this.value / this.max) * 100;
      }

      isZero() {
        return this.value <= 0;
      }

      resetFlags() {
        this._wasZero = false;
        this.finishedBeforeUser = false;
      }
    }

    /* ------------------------------------------------------------
       Game runtime variables
       ------------------------------------------------------------ */
    let lastTs = performance.now();
    let running = false;
    let userEnded = false;

    let rngUserClick, rngNpcClick, rngNpcInit, rngBirchPerNpc;
    let effects, USER, NPCS;

    /* ------------------------------------------------------------
       Initialization
       ------------------------------------------------------------ */
    function initRNGs() {
      rngUserClick = mulberry32(CONFIG.SEEDS.USER_CLICK);
      rngNpcClick = mulberry32(CONFIG.SEEDS.NPC_CLICK);
      rngNpcInit = mulberry32(CONFIG.SEEDS.NPC_INIT);

      rngBirchPerNpc = [];
      for (let i = 0; i < CONFIG.NPC.COUNT; i += 1) {
        rngBirchPerNpc.push(mulberry32((CONFIG.SEEDS.BIRCH + i * 0x9E3779B9) >>> 0));
      }
    }

    function initRun() {
      // Create fresh actors/effects for a new run
      effects = new TimedEffects();
      USER = new Actor(CONFIG.USER.MAX_STAMINA, CONFIG.USER.BASE_TICK_SPEED, CONFIG.USER.DISPLAY_DECIMALS);

      const npcSteps = CONFIG.NPC.STAMINA_STEPS;
      NPCS = Array.from({ length: CONFIG.NPC.COUNT }).map(() => {
        const stepIdx = randIntRange(rngNpcInit, 0, npcSteps.length - 1);
        const max = npcSteps[stepIdx];
        return new Actor(max, CONFIG.NPC.BASE_TICK_SPEED, CONFIG.NPC.DISPLAY_DECIMALS);
      });

      // Ensure flags are reset
      USER.resetFlags();
      NPCS.forEach(n => n.resetFlags());

      // Reset time base
      lastTs = performance.now();
    }

    function initGame() {
      loadCoins();
      initRNGs();
      initRun();
      GameState.set(CONFIG.STATE.START);
      userEnded = false;
      running = false;
    }

    /* ------------------------------------------------------------
       State transitions
       ------------------------------------------------------------ */
    function startRun() {
      // Enter playing state and start ticking
      userEnded = false;
      document.getElementById('time-up').textContent = '';

      initRun();
      buildNPCsDOM();

      running = true;
      GameState.set('playing');

      updateUI();
      syncUIState();
    }

    function endToMenu(message = '') {
      // Return to menu, stop ticking (for future states this is the single place to do it)
      running = false;
      GameState.set('menu');
      document.getElementById('time-up').textContent = message;
      syncUIState();
      updateUI();
    }

    function resetRun() {
      // Reset current run (does not touch coins/inventory)
      userEnded = false;
      document.getElementById('time-up').textContent = '';
      initRNGs();
      initRun();
      buildNPCsDOM();
      updateUI();
      // Keep current state; if playing keep running true, if menu keep false
      running = GameState.is('playing');
      syncUIState();
    }

    /* ------------------------------------------------------------
       UI state syncing
       ------------------------------------------------------------ */
    function syncUIState() {
      const inMenu = GameState.is('menu');

      // Action buttons are only active while playing
      ['action-btn', 'beer-btn', 'icecream-btn', 'hat-btn'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.disabled = inMenu;
      });

      // NPC Birch buttons only active while playing
      document.querySelectorAll('.birch-btn').forEach(btn => {
        btn.disabled = inMenu;
      });

      // Shop buttons only active in menu
      document.querySelectorAll('.shop-btn').forEach(btn => {
        btn.disabled = !inMenu;
      });

      // Go In only active in menu
      const go = document.getElementById('go-btn');
      if (go) go.disabled = !inMenu;

      // Reset always enabled
      const reset = document.getElementById('reset-btn');
      if (reset) reset.disabled = false;
    }

    /* ------------------------------------------------------------
       DOM helpers & buttons
       ------------------------------------------------------------ */
    let $btnAction, $btnBeer, $btnIceCream, $btnHat, $btnReset;

    function bindStaticButtons() {
      $btnAction = document.getElementById('action-btn');
      $btnBeer = document.getElementById('beer-btn');
      $btnIceCream = document.getElementById('icecream-btn');
      $btnHat = document.getElementById('hat-btn');
      $btnReset = document.getElementById('reset-btn');

      $btnAction.addEventListener('click', () => withDelay($btnAction, CONFIG.DELAYS.WATER, onWater));
      $btnBeer.addEventListener('click', () => withDelay($btnBeer, CONFIG.DELAYS.BEER, onBeer));
      $btnIceCream.addEventListener('click', () => withDelay($btnIceCream, CONFIG.DELAYS.ICE_CREAM, onIceCream));
      $btnHat.addEventListener('click', () => withDelay($btnHat, CONFIG.DELAYS.HAT, onHat));
      $btnReset.addEventListener('click', () => withDelay($btnReset, CONFIG.DELAYS.RESET, resetRun));

      // Go In
      document.getElementById('go-btn').addEventListener('click', startRun);

      // Shop
      document.getElementById('buy-water').addEventListener('click', () => buyItem('WATER'));
      document.getElementById('buy-beer').addEventListener('click', () => buyItem('BEER'));
      document.getElementById('buy-icecream').addEventListener('click', () => buyItem('ICE_CREAM'));
      document.getElementById('buy-hat').addEventListener('click', () => buyItem('HAT'));
    }

    function withDelay(buttonEl, delayS, fn) {
      // Delay modifier: disable button after click for delayS seconds
      if (buttonEl.disabled) return;
      fn();
      buttonEl.disabled = true;
      setTimeout(() => {
        // Don't re-enable if UI state wants it disabled
        buttonEl.disabled = false;
        syncUIState();
      }, Math.max(0, delayS) * 1000);
    }

    function buildNPCsDOM() {
      const root = document.getElementById('npcs');
      root.innerHTML = '';

      NPCS.forEach((npc, i) => {
        const node = document.createElement('div');
        node.className = 'npc';
        node.innerHTML = `
          <div>
            <strong>NPC ${i + 1}:</strong>
            <span class="npc-value">${npc.asText()}</span>
            <span class="tag">(max ${npc.max})</span>
          </div>
          <div class="bar-container">
            <div class="bar npc-bar" style="width:${npc.percent()}%"></div>
          </div>
          <div class="row">
            <button class="birch-btn" data-idx="${i}">Birch</button>
            <span class="npc-status tag"></span>
          </div>
        `;
        root.appendChild(node);
      });

      // Bind per-NPC Birch buttons with per-button delay
      root.querySelectorAll('.birch-btn').forEach(btn => {
        const idx = parseInt(btn.dataset.idx, 10);
        btn.addEventListener('click', () => withDelay(btn, CONFIG.DELAYS.BIRCH, () => onBirch(idx)));
      });

      syncUIState();
    }

    /* ------------------------------------------------------------
       Effect application helpers
       ------------------------------------------------------------ */
    function applyHatMultiplier(value, isUser) {
      const hatActive = effects.isActive('hat');
      const cfg = CONFIG.EFFECTS.HAT;
      if (!hatActive) return value;
      if (cfg.AFFECTS_USER_ONLY && !isUser) return value;
      return value * cfg.REDUCTION_FACTOR;
    }

    function updateFinishedFlagsAfterManualDamage() {
      // When a click action sets NPC stamina to 0, we need to record whether
      // the NPC finished before the user (for reward coins).
      NPCS.forEach(n => {
        if (!n._wasZero && n.isZero()) {
          n._wasZero = true;
          if (!USER.isZero()) n.finishedBeforeUser = true;
        }
      });
    }

    /* ------------------------------------------------------------
       Actions (consume inventory)
       ------------------------------------------------------------ */
    function onWater() {
      if (!consumeItem('WATER')) return;

      const [uMin, uMax] = CONFIG.CLICK.USER_REDUCTION_RANGE;
      const [nMin, nMax] = CONFIG.CLICK.NPC_REDUCTION_RANGE;

      let userReduction = randIntRange(rngUserClick, uMin, uMax);
      userReduction = applyHatMultiplier(userReduction, true);
      USER.value = Math.max(0, USER.value - userReduction);

      NPCS.forEach(npc => {
        let r = randIntRange(rngNpcClick, nMin, nMax);
        r = applyHatMultiplier(r, false);
        npc.value = Math.max(0, npc.value - r);
      });

      updateFinishedFlagsAfterManualDamage();
      updateUI();
      checkEndState();
    }

    function onBeer() {
      if (!consumeItem('BEER')) return;

      const { SPEED_DELTA, DURATION_S } = CONFIG.EFFECTS.BEER;
      USER.addSpeed(SPEED_DELTA);

      effects.add({
        key: `beer:${Math.random()}`, // allow stacking
        durationS: DURATION_S,
        onExpire: () => USER.addSpeed(-SPEED_DELTA)
      });

      updateUI();
    }

    function onIceCream() {
      if (!consumeItem('ICE_CREAM')) return;

      const { AMOUNT } = CONFIG.EFFECTS.ICE_CREAM;
      USER.add(AMOUNT);
      USER.cap();
      updateUI();
    }

    function onHat() {
      if (!consumeItem('HAT')) return;

      const { DURATION_S } = CONFIG.EFFECTS.HAT;
      effects.add({ key: 'hat', durationS: DURATION_S });
      updateUI();
    }

    function onBirch(npcIndex) {
      const npc = NPCS[npcIndex];
      const [bMin, bMax] = CONFIG.CLICK.BIRCH_REDUCTION_RANGE;

      let dmg = randIntRange(rngBirchPerNpc[npcIndex], bMin, bMax);
      if (CONFIG.CLICK.BIRCH_AFFECTED_BY_HAT) {
        dmg = applyHatMultiplier(dmg, false);
      }

      npc.value = Math.max(0, npc.value - dmg);
      updateFinishedFlagsAfterManualDamage();
      updateUI();
      checkEndState();
    }

    /* ------------------------------------------------------------
       Animation loop (smooth ticking) & reward / state logic
       ------------------------------------------------------------ */
    function loop(ts) {
      const dt = (ts - lastTs) / 1000;
      lastTs = ts;

      // Purge expired effects even in menu, so UI tags clear correctly
      if (effects) effects.purgeExpired();

      if (running && GameState.is('playing')) {
        USER.tick(dt);
        NPCS.forEach(n => n.tick(dt));

        // Track who finished before the user
        NPCS.forEach(n => {
          if (!n._wasZero && n.isZero()) {
            n._wasZero = true;
            if (!USER.isZero()) n.finishedBeforeUser = true;
          }
        });

        updateUI();
        checkEndState();
      } else {
        // Still update effect tags even when paused
        updateUI();
      }

      requestAnimationFrame(loop);
    }

    function checkEndState() {
      if (!CONFIG.UI.DISABLE_BUTTONS_AT_ZERO) return;
      if (userEnded) return;

      if (USER.isZero()) {
        userEnded = true;
        running = false;

        // Reward coins: count NPCs that finished before user
        const reward = NPCS.reduce((acc, n) => acc + (n.finishedBeforeUser ? 1 : 0), 0);
        coins += reward;
        saveCoins();
        updateEconomyUI();

        // Return to menu state
        endToMenu('time is up');
      }
    }

    /* ------------------------------------------------------------
       UI updates
       ------------------------------------------------------------ */
    function updateUI() {
      // User UI
      document.getElementById('user-value').textContent = USER.asText();
      document.getElementById('user-bar').style.width = `${USER.percent()}%`;

      // Active effect tags
      const beerLeft = effects ? effects.sumRemainingByPrefix('beer:') : 0;
      const hatLeft = effects ? effects.getRemainingMax('hat') : 0;

      const tags = [];
      if (beerLeft > 0) tags.push(`Beer: ~${beerLeft.toFixed(0)}s`);
      if (hatLeft > 0) tags.push(`Hat: ${hatLeft.toFixed(0)}s`);
      document.getElementById('effect-tags').textContent = tags.join(' · ');

      // NPC UI
      const npcNodes = document.querySelectorAll('#npcs .npc');
      NPCS.forEach((npc, i) => {
        const node = npcNodes[i];
        if (!node) return;
        node.querySelector('.npc-value').textContent = npc.asText();
        node.querySelector('.npc-bar').style.width = `${npc.percent()}%`;
        if (npc.isZero()) node.querySelector('.npc-status').textContent = 'win';
      });

      // Speed hint
      document.getElementById('speed-tag').textContent = `Speed: ${USER.tickSpeed.toFixed(2)}/s`;

      // Keep economy UI fresh
      updateEconomyUI();
    }

    /* ------------------------------------------------------------
       Bootstrap
       ------------------------------------------------------------ */
    document.addEventListener('DOMContentLoaded', () => {
      bindStaticButtons();
      initGame();
      buildNPCsDOM();
      updateEconomyUI();
      updateUI();
      syncUIState();
      requestAnimationFrame(loop);
    });
  </script>
</head>

<body>
  <div class="section-header">
    <h2>User</h2>
    <div>Coins: <strong id="coins">0</strong></div>
  </div>

  <div class="stack">
    <div class="row">
      <div>
        <strong>Stamina:</strong>
        <span id="user-value"></span>
        <span class="tag" id="speed-tag"></span>
      </div>
    </div>

    <div class="bar-container">
      <div id="user-bar" class="bar"></div>
    </div>

    <div class="row">
      <button id="action-btn">Water</button>

      <div class="right-buttons">
        <button id="beer-btn">Beer</button>
        <button id="icecream-btn">Ice Cream</button>
        <button id="hat-btn">Hat</button>
        <button id="reset-btn">Reset</button>
      </div>
    </div>

    <div class="row small">
      <span id="effect-tags" class="tag"></span>
    </div>

    <div id="time-up" class="muted"></div>
  </div>

  <div class="panel">
    <div class="row">
      <button id="buy-water" class="shop-btn">Buy Water</button>
      <button id="buy-beer" class="shop-btn">Buy Beer</button>
      <button id="buy-icecream" class="shop-btn">Buy Ice Cream</button>
      <button id="buy-hat" class="shop-btn">Buy Hat</button>
    </div>

    <div class="row tag">
      Water: <span id="inv-WATER">0</span>
      Beer: <span id="inv-BEER">0</span>
      Ice Cream: <span id="inv-ICE_CREAM">0</span>
      Hat: <span id="inv-HAT">0</span>
    </div>

    <button id="go-btn">Go In</button>
  </div>

  <hr />

  <h2>NPCs</h2>
  <div id="npcs" class="stack"></div>

  <div class="panel small">
    <strong>Notes for editing:</strong>
    <ul>
      <li>Edit all numbers at the top in <code>CONFIG</code> (ranges, seeds, speeds, durations, delays, prices).</li>
      <li>Menu state: you can only buy items; action buttons and ticking are disabled.</li>
      <li>Playing state: action buttons consume inventory.</li>
      <li>When user stamina hits 0, the run ends and you return to menu. Earn 1 coin per NPC that hit 0 before you.</li>
    </ul>
  </div>
</body>
</html>
