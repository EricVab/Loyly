<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>POCv4</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --w: 320px;
      --h: 14px;
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      padding: 20px;
    }

    .row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .stack {
      display: grid;
      gap: 6px;
      margin-bottom: 20px;
    }

    .bar-container {
      width: var(--w);
      height: var(--h);
      border: 1px solid #000;
      position: relative;
      background: #eee;
    }

    .bar {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 100%;
      background: linear-gradient(90deg, #2ecc71, #27ae60);
    }

    .npc {
      margin-top: 10px;
    }

    .tag {
      font-size: 12px;
      opacity: 0.7;
    }

    button {
      padding: 6px 10px;
      cursor: pointer;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .right-buttons {
      display: inline-flex;
      gap: 8px;
      margin-left: 10px;
      flex-wrap: wrap;
    }

    .muted {
      color: #b00;
      font-weight: 600;
    }

    .panel {
      padding: 8px 10px;
      border: 1px dashed #aaa;
      background: #fafafa;
      margin-top: 12px;
    }

    .small {
      font-size: 12px;
    }

    .section-header {
      display: flex;
      gap: 12px;
      align-items: baseline;
    }

    /* XRAY transparency (NPC value + bar only) */
    .npc-scan {
      opacity: 0;
      transition: opacity 180ms ease-in-out;
    }

    body.xray-on .npc-scan {
      opacity: 1;
    }
  </style>

  <script>
    /* ============================================================
       CONFIG — All user-editable parameters live here
       ============================================================ */
    const CONFIG = {
      STATE: {
        START: 'menu'
      },

      EXIT: {
        // You must exit with > this many seconds remaining on the USER timer.
        // Example: 1.0 => must press Exit when remaining time is > 1.0s.
        TOLERANCE_S: 1.0
      },

      USER: {
        MAX_STAMINA: 100,           // starting & cap for user stamina
        BASE_TICK_SPEED: 3,         // default stamina drain speed [units per second]
        DISPLAY_DECIMALS: 0
      },

      NPC: {
        COUNT: 5,                   // how many NPCs to spawn
        STAMINA_STEPS: [50, 100, 150, 250], // NPC max stamina chosen from these
        BASE_TICK_SPEED: 3,         // NPC drain speed [units per second]
        DISPLAY_DECIMALS: 0
      },

      CLICK: {
        // Ranges for click effects (inclusive bounds)
        USER_REDUCTION_RANGE: [25, 50], // Water — user damage
        NPC_REDUCTION_RANGE: [25, 50],  // Water — per NPC damage
        BIRCH_REDUCTION_RANGE: [9, 18], // Birch — affects targeted NPC only
        BIRCH_AFFECTED_BY_HAT: false    // whether Hat also scales Birch clicks
      },

      SEEDS: {
        USER_CLICK: 12345, // seed for user click randomness (Water)
        NPC_CLICK: 67890,  // seed for NPC click randomness (Water)
        NPC_INIT: 13579,   // seed for picking NPC initial stamina steps
        BIRCH: 24680       // seed for Birch per-NPC (each NPC gets a derived stream)
      },

      EFFECTS: {
        BEER: {
          SPEED_DELTA: -1, // additive change to user tick speed (e.g., -1 => 3/s -> 2/s)
          DURATION_S: 10
        },

        WOOD: {
          SPEED_DELTA: +1, // additive change to tick speed (makes counters drain faster)
          DURATION_S: 10,  // similar duration style to Beer
          AFFECTS_USER: true,
          AFFECTS_NPCS: true
        },

        ICE_CREAM: {
          AMOUNT: 40
        },

        PLUNGE: {
          BONUS_BASE_STAMINA: 100 // permanently increases user's max stamina for the run
        },

        XRAY: {
          DURATION_S: 10
        },

        HAT: {
          REDUCTION_FACTOR: 0.20, // Water damage multiplier while Hat is active
          DURATION_S: 15,
          AFFECTS_USER_ONLY: true
        }
      },

      ECONOMY: {
        STARTING_COINS: 0,
        PERSIST_COINS: false, // if true, store coins in localStorage across reloads
        STORAGE_KEY: 'coins_total'
      },

      ITEMS: {
        WATER: { price: 0 },
        BEER: { price: 5 },
        ICE_CREAM: { price: 5 },
        HAT: { price: 10 },
        WOOD: { price: 0 },
        PLUNGE: { price: 2 },
        XRAY: { price: 5 }
      },

      DELAYS: {
        // "Delay" modifier: disable button after pressing for this many seconds
        WATER: 0.1,
        BEER: 5,
        ICE_CREAM: 10,
        HAT: 15,
        WOOD: 0.5,
        PLUNGE: 0,
        XRAY: 10,
        BIRCH: 0.1,
        RESET: 0,
        EXIT: 0
      },

      UI: {
        DISABLE_BUTTONS_AT_ZERO: true
      }
    };
    /* ===================== end CONFIG ===================== */

    /* ------------------------------------------------------------
       Game State (modular, extensible)
       ------------------------------------------------------------ */
    const GameState = {
      current: CONFIG.STATE.START,
      set(state) {
        this.current = state;
        syncUIState();
      },
      is(state) {
        return this.current === state;
      },
      isOneOf(states) {
        return states.includes(this.current);
      }
    };

    /* ------------------------------------------------------------
       Economy & Inventory
       - Purchases only allowed in menu-like states.
       - Action buttons consume inventory while playing.
       ------------------------------------------------------------ */
    let coins = CONFIG.ECONOMY.STARTING_COINS;

    const inventory = {
      WATER: 0,
      BEER: 0,
      ICE_CREAM: 0,
      HAT: 0,
      WOOD: 0,
      PLUNGE: 0,
      XRAY: 0
    };

    function loadCoins() {
      if (!CONFIG.ECONOMY.PERSIST_COINS) return;
      const raw = localStorage.getItem(CONFIG.ECONOMY.STORAGE_KEY);
      const val = raw ? Number(raw) : NaN;
      coins = Number.isFinite(val) ? val : CONFIG.ECONOMY.STARTING_COINS;
    }

    function saveCoins() {
      if (!CONFIG.ECONOMY.PERSIST_COINS) return;
      localStorage.setItem(CONFIG.ECONOMY.STORAGE_KEY, String(coins));
    }

    function canAfford(itemKey) {
      return coins >= CONFIG.ITEMS[itemKey].price;
    }

    function isShopOpenState() {
      // You can buy items in menu, win, or lose states
      return GameState.isOneOf(['menu', 'win', 'lose']);
    }

    function canBuyItemInCurrentState(itemKey) {
      // Plunge is special: can ONLY be purchased in menu state.
      if (itemKey === 'PLUNGE') return GameState.is('menu');
      return isShopOpenState();
    }

    function buyItem(itemKey) {
      if (!canBuyItemInCurrentState(itemKey)) return;
      if (!canAfford(itemKey)) return;
      coins -= CONFIG.ITEMS[itemKey].price;
      inventory[itemKey] += 1;
      saveCoins();
      updateEconomyUI();
    }

    function consumeItem(itemKey) {
      if (inventory[itemKey] <= 0) return false;
      inventory[itemKey] -= 1;
      updateEconomyUI();
      return true;
    }

    function updateEconomyUI() {
      document.getElementById('coins').textContent = String(coins);
      for (const k of Object.keys(inventory)) {
        const el = document.getElementById(`inv-${k}`);
        if (el) el.textContent = String(inventory[k]);
      }
    }

    /* ------------------------------------------------------------
       Seedable PRNG utilities (deterministic randoms per feature)
       ------------------------------------------------------------ */
    function mulberry32(seed) {
      let t = seed >>> 0;
      return function () {
        t += 0x6D2B79F5;
        let r = Math.imul(t ^ (t >>> 15), 1 | t);
        r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
        return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
      };
    }

    function randIntRange(rng, min, max) {
      // inclusive integer range using provided rng()
      const x = rng();
      return Math.floor(x * (max - min + 1)) + min;
    }

    /* ------------------------------------------------------------
       TimedEffects: time-bound modifiers (Beer / Wood / Hat / etc.)
       ------------------------------------------------------------ */
    class TimedEffects {
      constructor() {
        this.effects = [];
      }

      now() {
        return performance.now() / 1000; // seconds
      }

      add({ key, durationS, data = {}, onApply = null, onExpire = null }) {
        const t = this.now();
        const eff = { key, until: t + durationS, onExpire, data };
        if (onApply) onApply(eff);
        this.effects.push(eff);
      }

      purgeExpired() {
        const t = this.now();
        this.effects = this.effects.filter(e => {
          if (e.until <= t) {
            if (e.onExpire) e.onExpire(e);
            return false;
          }
          return true;
        });
      }

      getRemainingMax(exactKey) {
        const t = this.now();
        let maxLeft = 0;
        this.effects.forEach(e => {
          if (e.key === exactKey && e.until > t) {
            maxLeft = Math.max(maxLeft, e.until - t);
          }
        });
        return maxLeft;
      }
      // Utility: sum remaining time for effects whose key starts with a prefix
            sumRemainingByPrefix(prefix) {
        const t = this.now();
        return this.effects
          .filter(e => String(e.key).startsWith(prefix) && e.until > t)
          .reduce((acc, e) => acc + (e.until - t), 0);
      }

      isPrefixActive(prefix) {
        return this.sumRemainingByPrefix(prefix) > 0;
      }
    }

    /* ------------------------------------------------------------
       Core game actors
       ------------------------------------------------------------ */
    class Actor {
      constructor(max, baseTickSpeed, displayDecimals = 0) {
        this.max = max;
        this.value = max;
        this.baseTickSpeed = baseTickSpeed;
        this.displayDecimals = displayDecimals;
        this.speedAdditions = 0;
        // meta flags for reward logic
        this._wasZero = false;
        this.finishedBeforeUser = false;
      }

      get tickSpeed() {
        return Math.max(0, this.baseTickSpeed + this.speedAdditions);
      }

      tick(dt) {
        this.value = Math.max(0, this.value - this.tickSpeed * dt);
      }

      addSpeed(delta) {
        this.speedAdditions += delta;
      }

      cap() {
        this.value = Math.min(this.max, this.value);
      }

      add(amount) {
        this.value = Math.min(this.max, this.value + amount);
      }

      asText() {
        return this.value.toFixed(this.displayDecimals);
      }

      percent() {
        return (this.value / this.max) * 100;
      }

      isZero() {
        return this.value <= 0;
      }

      resetFlags() {
        this._wasZero = false;
        this.finishedBeforeUser = false;
      }
    }

    /* ------------------------------------------------------------
       Game runtime variables
       ------------------------------------------------------------ */
    let lastTs = performance.now();
    let running = false;
    let userEnded = false;

    let rngUserClick, rngNpcClick, rngNpcInit, rngBirchPerNpc;
    let effects, USER, NPCS;

    /* ------------------------------------------------------------
       Initialization
       ------------------------------------------------------------ */
    function initRNGs() {
      rngUserClick = mulberry32(CONFIG.SEEDS.USER_CLICK);
      rngNpcClick = mulberry32(CONFIG.SEEDS.NPC_CLICK);
      rngNpcInit = mulberry32(CONFIG.SEEDS.NPC_INIT);

      rngBirchPerNpc = [];
      for (let i = 0; i < CONFIG.NPC.COUNT; i += 1) {
        rngBirchPerNpc.push(mulberry32((CONFIG.SEEDS.BIRCH + i * 0x9E3779B9) >>> 0));
      }
    }

    function initRun() {
      // Create fresh actors/effects for a new run
      effects = new TimedEffects();

      USER = new Actor(CONFIG.USER.MAX_STAMINA, CONFIG.USER.BASE_TICK_SPEED, CONFIG.USER.DISPLAY_DECIMALS);

      const npcSteps = CONFIG.NPC.STAMINA_STEPS;
      NPCS = Array.from({ length: CONFIG.NPC.COUNT }).map(() => {
        const stepIdx = randIntRange(rngNpcInit, 0, npcSteps.length - 1);
        const max = npcSteps[stepIdx];
        return new Actor(max, CONFIG.NPC.BASE_TICK_SPEED, CONFIG.NPC.DISPLAY_DECIMALS);
      });

      // Ensure flags are reset
      USER.resetFlags();
      NPCS.forEach(n => n.resetFlags());

      // Reset time base
      lastTs = performance.now();
    }

    function initGame() {
      loadCoins();
      initRNGs();
      initRun();
      GameState.set(CONFIG.STATE.START);
      userEnded = false;
      running = false;
      updateEconomyUI();
    }

    /* ------------------------------------------------------------
       State transitions
       ------------------------------------------------------------ */
    function startRun() {
      // Enter playing state and start ticking
      userEnded = false;
      document.getElementById('time-up').textContent = '';

      initRun();
      buildNPCsDOM();

      running = true;
      GameState.set('playing');

      updateUI();
      syncUIState();
    }

    function endRunTo(state, message = '') {
      // Single exit point for run-ending states
      running = false;
      GameState.set(state);
      document.getElementById('time-up').textContent = message;
      syncUIState();
      updateUI();
    }

    function computePotentialReward() {
      return NPCS.reduce((acc, n) => acc + (n.finishedBeforeUser ? 1 : 0), 0);
    }

    function winRun() {
      if (!GameState.is('playing')) return;
      const reward = computePotentialReward();
      coins += reward;
      saveCoins();
      updateEconomyUI();
      endRunTo('win', reward > 0 ? `win (+${reward} coins)` : 'win');
    }

    function loseRun(reason = 'lose') {
      if (!GameState.is('playing')) return;
      endRunTo('lose', reason);
    }

    function resetRun() {
      // Reset current run (does not touch coins/inventory)
      userEnded = false;
      document.getElementById('time-up').textContent = '';
      initRNGs();
      initRun();
      buildNPCsDOM();
      updateUI();
      // Keep current state; if playing keep running true, otherwise false
      running = GameState.is('playing');
      syncUIState();
    }

    /* ------------------------------------------------------------
       UI state syncing
       ------------------------------------------------------------ */
    function syncUIState() {
      const inPlaying = GameState.is('playing');
      const inShop = isShopOpenState();
      // Action buttons are only active while playing
      ['action-btn', 'beer-btn', 'icecream-btn', 'hat-btn', 'wood-btn', 'plunge-btn', 'xray-btn'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.disabled = !inPlaying;
      });

      // Exit button is only active while playing
      const exitBtn = document.getElementById('exit-btn');
      if (exitBtn) exitBtn.disabled = !inPlaying;

      // NPC Birch buttons only active while playing
      document.querySelectorAll('.birch-btn').forEach(btn => {
        btn.disabled = !inPlaying;
      });

      // Shop buttons only active in menu-like states
      document.querySelectorAll('.shop-btn').forEach(btn => {
        btn.disabled = !inShop;
      });

      // Enforce the special purchasing rule for Plunge
      const buyPlunge = document.getElementById('buy-plunge');
      if (buyPlunge) buyPlunge.disabled = !GameState.is('menu');

      const go = document.getElementById('go-btn');
      if (go) go.disabled = !inShop;

      // Reset always enabled
      const reset = document.getElementById('reset-btn');
      if (reset) reset.disabled = false;
    }

    /* ------------------------------------------------------------
       DOM helpers & buttons
       ------------------------------------------------------------ */
    let $btnWater, $btnBeer, $btnIceCream, $btnHat, $btnWood, $btnPlunge, $btnXray, $btnExit, $btnReset;

    function bindStaticButtons() {
      $btnWater = document.getElementById('action-btn');
      $btnBeer = document.getElementById('beer-btn');
      $btnIceCream = document.getElementById('icecream-btn');
      $btnHat = document.getElementById('hat-btn');
      $btnWood = document.getElementById('wood-btn');
      $btnPlunge = document.getElementById('plunge-btn');
      $btnXray = document.getElementById('xray-btn');
      $btnExit = document.getElementById('exit-btn');
      $btnReset = document.getElementById('reset-btn');

      $btnWater.addEventListener('click', () => withDelay($btnWater, CONFIG.DELAYS.WATER, onWater));
      $btnBeer.addEventListener('click', () => withDelay($btnBeer, CONFIG.DELAYS.BEER, onBeer));
      $btnIceCream.addEventListener('click', () => withDelay($btnIceCream, CONFIG.DELAYS.ICE_CREAM, onIceCream));
      $btnHat.addEventListener('click', () => withDelay($btnHat, CONFIG.DELAYS.HAT, onHat));
      $btnWood.addEventListener('click', () => withDelay($btnWood, CONFIG.DELAYS.WOOD, onWood));
      $btnPlunge.addEventListener('click', () => withDelay($btnPlunge, CONFIG.DELAYS.PLUNGE, onPlunge));
      $btnXray.addEventListener('click', () => withDelay($btnXray, CONFIG.DELAYS.XRAY, onXray));

      // Exit: win only if remaining time is above tolerance
      $btnExit.addEventListener('click', () => withDelay($btnExit, CONFIG.DELAYS.EXIT, attemptExit));

      $btnReset.addEventListener('click', () => withDelay($btnReset, CONFIG.DELAYS.RESET, resetRun));

      // Go In
      document.getElementById('go-btn').addEventListener('click', startRun);

      // Shop
      document.getElementById('buy-water').addEventListener('click', () => buyItem('WATER'));
      document.getElementById('buy-beer').addEventListener('click', () => buyItem('BEER'));
      document.getElementById('buy-wood').addEventListener('click', () => buyItem('WOOD'));
      document.getElementById('buy-icecream').addEventListener('click', () => buyItem('ICE_CREAM'));
      document.getElementById('buy-hat').addEventListener('click', () => buyItem('HAT'));
      document.getElementById('buy-plunge').addEventListener('click', () => buyItem('PLUNGE'));
      document.getElementById('buy-xray').addEventListener('click', () => buyItem('XRAY'));
    }

    function withDelay(buttonEl, delayS, fn) {
      // Delay modifier: disable button after click for delayS seconds
      if (buttonEl.disabled) return;
      fn();
      buttonEl.disabled = true;
      setTimeout(() => {
        // Don't re-enable if UI state wants it disabled
        buttonEl.disabled = false;
        syncUIState();
      }, Math.max(0, delayS) * 1000);
    }

    function buildNPCsDOM() {
      const root = document.getElementById('npcs');
      root.innerHTML = '';

      NPCS.forEach((npc, i) => {
        const node = document.createElement('div');
        node.className = 'npc';
        node.innerHTML = `
          <div>
            <strong>NPC ${i + 1}:</strong>
            <span class="npc-value npc-scan">${npc.asText()}</span>
            <span class="tag npc-scan">(max ${npc.max})</span>
          </div>
          <div class="bar-container npc-scan">
            <div class="bar npc-bar" style="width:${npc.percent()}%"></div>
          </div>
          <div class="row">
            <button class="birch-btn" data-idx="${i}">Birch</button>
            <span class="npc-status tag"></span>
          </div>
        `;
        root.appendChild(node);
      });

      // Bind per-NPC Birch buttons with per-button delay
      root.querySelectorAll('.birch-btn').forEach(btn => {
        const idx = parseInt(btn.dataset.idx, 10);
        btn.addEventListener('click', () => withDelay(btn, CONFIG.DELAYS.BIRCH, () => onBirch(idx)));
      });

      syncUIState();
    }

    /* ------------------------------------------------------------
       Effect application helpers
       ------------------------------------------------------------ */
    function applyHatMultiplier(value, isUser) {
      const hatActive = effects.getRemainingMax('hat') > 0;
      const cfg = CONFIG.EFFECTS.HAT;
      if (!hatActive) return value;
      if (cfg.AFFECTS_USER_ONLY && !isUser) return value;
      return value * cfg.REDUCTION_FACTOR;
    }

    function updateFinishedFlagsAfterManualDamage() {
      // When a click action sets NPC stamina to 0, record if NPC finished before user
      NPCS.forEach(n => {
        if (!n._wasZero && n.isZero()) {
          n._wasZero = true;
          if (!USER.isZero()) n.finishedBeforeUser = true;
        }
      });
    }

    function applySpeedDeltaToUserAndNpcs(delta) {
      USER.addSpeed(delta);
      NPCS.forEach(n => n.addSpeed(delta));
    }

    function remainingUserTimeS() {
      // Remaining time in seconds, based on current tick speed
      const speed = Math.max(1e-9, USER.tickSpeed);
      return USER.value / speed;
    }

    /* ------------------------------------------------------------
       Actions (consume inventory)
       ------------------------------------------------------------ */
    function onWater() {
      if (!consumeItem('WATER')) return;

      const [uMin, uMax] = CONFIG.CLICK.USER_REDUCTION_RANGE;
      const [nMin, nMax] = CONFIG.CLICK.NPC_REDUCTION_RANGE;

      let userReduction = randIntRange(rngUserClick, uMin, uMax);
      userReduction = applyHatMultiplier(userReduction, true);
      USER.value = Math.max(0, USER.value - userReduction);

      NPCS.forEach(npc => {
        let r = randIntRange(rngNpcClick, nMin, nMax);
        r = applyHatMultiplier(r, false);
        npc.value = Math.max(0, npc.value - r);
      });

      updateFinishedFlagsAfterManualDamage();
      updateUI();
      checkEndState();
    }

    function onBeer() {
      if (!consumeItem('BEER')) return;

      const { SPEED_DELTA, DURATION_S } = CONFIG.EFFECTS.BEER;
      USER.addSpeed(SPEED_DELTA);

      effects.add({
        key: `beer:${Math.random()}`,
        durationS: DURATION_S,
        onExpire: () => USER.addSpeed(-SPEED_DELTA)
      });

      updateUI();
    }

    function onWood() {
      if (!consumeItem('WOOD')) return;

      const { SPEED_DELTA, DURATION_S, AFFECTS_USER, AFFECTS_NPCS } = CONFIG.EFFECTS.WOOD;
      const delta = SPEED_DELTA;

      if (AFFECTS_USER && AFFECTS_NPCS) {
        applySpeedDeltaToUserAndNpcs(delta);
        effects.add({
          key: `wood:${Math.random()}`,
          durationS: DURATION_S,
          onExpire: () => applySpeedDeltaToUserAndNpcs(-delta)
        });
      } else {
        // Fall back to flexible targeting (future-proof)
        if (AFFECTS_USER) USER.addSpeed(delta);
        if (AFFECTS_NPCS) NPCS.forEach(n => n.addSpeed(delta));
        effects.add({
          key: `wood:${Math.random()}`,
          durationS: DURATION_S,
          onExpire: () => {
            if (AFFECTS_USER) USER.addSpeed(-delta);
            if (AFFECTS_NPCS) NPCS.forEach(n => n.addSpeed(-delta));
          }
        });
      }

      updateUI();
    }

    function onIceCream() {
      if (!consumeItem('ICE_CREAM')) return;

      const { AMOUNT } = CONFIG.EFFECTS.ICE_CREAM;
      USER.add(AMOUNT);
      USER.cap();
      updateUI();
    }

    function onPlunge() {
      if (!consumeItem('PLUNGE')) return;

      const { BONUS_BASE_STAMINA } = CONFIG.EFFECTS.PLUNGE;
      // Increase max and current by the same amount (permanent for this run)
      USER.max += BONUS_BASE_STAMINA;
      USER.value += BONUS_BASE_STAMINA;
      USER.cap();
      updateUI();
    }

    function onXray() {
      if (!consumeItem('XRAY')) return;

      const { DURATION_S } = CONFIG.EFFECTS.XRAY;
      effects.add({
        key: `xray:${Math.random()}`,
        durationS: DURATION_S
      });
      updateUI();
    }

    function onHat() {
      if (!consumeItem('HAT')) return;

      const { DURATION_S } = CONFIG.EFFECTS.HAT;
      effects.add({ key: 'hat', durationS: DURATION_S });
      updateUI();
    }

    function onBirch(npcIndex) {
      const npc = NPCS[npcIndex];
      const [bMin, bMax] = CONFIG.CLICK.BIRCH_REDUCTION_RANGE;

      let dmg = randIntRange(rngBirchPerNpc[npcIndex], bMin, bMax);
      if (CONFIG.CLICK.BIRCH_AFFECTED_BY_HAT) {
        dmg = applyHatMultiplier(dmg, false);
      }

      npc.value = Math.max(0, npc.value - dmg);
      updateFinishedFlagsAfterManualDamage();
      updateUI();
      checkEndState();
    }

    /* ------------------------------------------------------------
       Exit logic with tolerance
       ------------------------------------------------------------ */
    function attemptExit() {
      if (!GameState.is('playing')) return;

      const remaining = remainingUserTimeS();
      const tol = CONFIG.EXIT.TOLERANCE_S;

      // Must exit strictly above tolerance.
      if (remaining > tol) {
        winRun();
      } else {
        // Attempted exit too late => lose immediately
        loseRun('exit too late');
      }
    }

    /* ------------------------------------------------------------
       Loop & end conditions
       ------------------------------------------------------------ */
    function loop(ts) {
      const dt = (ts - lastTs) / 1000;
      lastTs = ts;

      // Purge expired effects even when not playing, so UI tags clear correctly
      if (effects) effects.purgeExpired();

      if (running && GameState.is('playing')) {
        USER.tick(dt);
        NPCS.forEach(n => n.tick(dt));

        // Track who finished before the user
        NPCS.forEach(n => {
          if (!n._wasZero && n.isZero()) {
            n._wasZero = true;
            if (!USER.isZero()) n.finishedBeforeUser = true;
          }
        });

        updateUI();
        checkEndState();
      } else {
        // Still update effect tags even when paused
        updateUI();
      }

      requestAnimationFrame(loop);
    }

    function checkEndState() {
      if (!CONFIG.UI.DISABLE_BUTTONS_AT_ZERO) return;
      if (userEnded) return;

      if (USER.isZero()) {
        userEnded = true;
        running = false;
        loseRun('lose');
      }
    }

    /* ------------------------------------------------------------
       UI updates
       ------------------------------------------------------------ */
    function updateUI() {
      // XRAY toggles NPC scan visibility via body class
      const xrayActive = effects ? effects.isPrefixActive('xray:') : false;
      document.body.classList.toggle('xray-on', xrayActive);

      // User UI
      document.getElementById('user-value').textContent = USER.asText();
      document.getElementById('user-bar').style.width = `${USER.percent()}%`;

      // Active effect tags
      const beerLeft = effects ? effects.sumRemainingByPrefix('beer:') : 0;
      const woodLeft = effects ? effects.sumRemainingByPrefix('wood:') : 0;
      const xrayLeft = effects ? effects.sumRemainingByPrefix('xray:') : 0;
      const hatLeft = effects ? effects.getRemainingMax('hat') : 0;

      const tags = [];
      if (beerLeft > 0) tags.push(`Beer: ~${beerLeft.toFixed(0)}s`);
      if (woodLeft > 0) tags.push(`Wood: ~${woodLeft.toFixed(0)}s`);
      if (xrayLeft > 0) tags.push(`Xray: ~${xrayLeft.toFixed(0)}s`);
      if (hatLeft > 0) tags.push(`Hat: ${hatLeft.toFixed(0)}s`);
      document.getElementById('effect-tags').textContent = tags.join(' · ');

      // NPC UI
      const npcNodes = document.querySelectorAll('#npcs .npc');
      NPCS.forEach((npc, i) => {
        const node = npcNodes[i];
        if (!node) return;

        // Only update the hidden elements too (so they are correct when revealed)
        node.querySelector('.npc-value').textContent = npc.asText();
        node.querySelector('.npc-bar').style.width = `${npc.percent()}%`;

        if (npc.isZero()) node.querySelector('.npc-status').textContent = 'win';
      });

      // Speed hint
      document.getElementById('speed-tag').textContent = `Speed: ${USER.tickSpeed.toFixed(2)}/s`;

      // Potential reward
      const info = document.getElementById('run-info');
      if (info) {
        if (GameState.is('playing')) {
          info.textContent = `Potential reward: ${computePotentialReward()} · Exit> ${CONFIG.EXIT.TOLERANCE_S.toFixed(2)}s`;
        } else {
          info.textContent = '';
        }
      }

      // Keep economy UI fresh
      updateEconomyUI();
    }

    /* ------------------------------------------------------------
       Bootstrap
       ------------------------------------------------------------ */
    document.addEventListener('DOMContentLoaded', () => {
      bindStaticButtons();
      initGame();
      buildNPCsDOM();
      updateEconomyUI();
      updateUI();
      syncUIState();
      requestAnimationFrame(loop);
    });
  </script>
</head>

<body>
  <div class="section-header">
    <h2>User</h2>
    <div>Coins: <strong id="coins">0</strong></div>
  </div>

  <div class="stack">
    <div class="row">
      <div>
        <strong>Stamina:</strong>
        <span id="user-value"></span>
        <span class="tag" id="speed-tag"></span>
      </div>
    </div>

    <div class="bar-container">
      <div id="user-bar" class="bar"></div>
    </div>

    <div class="row">
      <button id="action-btn">Water</button>

      <div class="right-buttons">
        <button id="beer-btn">Beer</button>
        <button id="wood-btn">Wood</button>
        <button id="icecream-btn">Ice Cream</button>
        <button id="plunge-btn">Plunge</button>
        <button id="xray-btn">Xray</button>
        <button id="hat-btn">Hat</button>
        <button id="exit-btn">Exit</button>
        <button id="reset-btn">Reset</button>
      </div>
    </div>

    <div class="row small">
      <span id="effect-tags" class="tag"></span>
      <span id="run-info" class="tag"></span>
    </div>

    <div id="time-up" class="muted"></div>
  </div>

  <div class="panel">
    <div class="row">
      <button id="buy-water" class="shop-btn">Buy Water</button>
      <button id="buy-beer" class="shop-btn">Buy Beer</button>
      <button id="buy-wood" class="shop-btn">Buy Wood</button>
      <button id="buy-icecream" class="shop-btn">Buy Ice Cream</button>
      <button id="buy-hat" class="shop-btn">Buy Hat</button>
      <button id="buy-plunge" class="shop-btn">Buy Plunge</button>
      <button id="buy-xray" class="shop-btn">Buy Xray</button>
    </div>

    <div class="row tag">
      Water: <span id="inv-WATER">0</span>
      Beer: <span id="inv-BEER">0</span>
      Wood: <span id="inv-WOOD">0</span>
      Ice Cream: <span id="inv-ICE_CREAM">0</span>
      Plunge: <span id="inv-PLUNGE">0</span>
      Xray: <span id="inv-XRAY">0</span>
      Hat: <span id="inv-HAT">0</span>
    </div>

    <button id="go-btn">Go In</button>
  </div>

  <hr />

  <h2>NPCs</h2>
  <div id="npcs" class="stack"></div>

  <div class="panel small">
    <strong>Notes for editing:</strong>
    <ul>
      <li>Go in the sauna and try to outlast all other NPCs.</li>
      <li>Remember to exit the sauna before your stamina runs out or you will faint!</li>
      <li>Outlasting other NPCs will give you money which you can spend on items in the store.</li>
      <li>Smacking NPCs with a birch whisk will lower their stamina and is free!</li>
      <table>
        <tr>
          <th>Item</th>
          <th>Price</th>
          <th>Effect</th>
        </tr>
        <tr>
          <td>Water</td>
          <th>Free</th>
          <td>Throw water on the hot coals, everyone in the sauna takes a random amount of damage</td>
        </tr>
        <tr>
          <td>Beer</td>
          <th>5</th>
          <td>Drink beer to make you numb and lower your stamina drain rate</td>
        </tr>
        <tr>
          <td>Wood</td>
          <th>Free</th>
          <td>Add wood to the stove increasing the temperaturue in the sauna, increases stamina drain rate for all</td>
        </tr>
        <tr>
          <td>Ice Cream</td>
          <th>5</th>
          <td>Cold treat in the sauna to restore your stamina</td>
        </tr>
        <tr>
          <td>Hat</td>
          <th>10</th>
          <td>Wear a proper sauna hat, you take less damage when throwing water on the stones</td>
        </tr>
        <tr>
          <td>Plunge</td>
          <th>2</th>
          <td>Take a cold plunge before entering the sauna, increases your stamina before entering the sauna</td>
        </tr>
        <tr>
          <td>Xray</td>
          <th>5</th>
          <td>Allows you to seee the remaining stamina of other NPCs</td>
        </tr>
      </table>
    </ul>
  </div>
</body>
</html>
